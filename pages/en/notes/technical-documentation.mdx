export const meta = {
  title: "Technical Documentation",
  publishedAt: "2021-05-14",
  modifiedAt: "2021-05-14",
};

# Technical Documentation

## Entities

### User

A user has one Ed25519 keypair. The private key must be storred in a secure store on the device (Keychain Services/Android keystore system).
In addition a user has a user ID which is generated by the server.

#### Possible Improvements

In the future there ideally would be mutliple Ed25519 keypairs per user.
This way one keypair could invalid e.g. when a user looses a device and wants to invalidate one keypair, but not the others.
The downside of this is that it increases complexity for contact and device verification.

<!--

### Device

A device is a

The device is storred in the secure keychain ->

Reference: https://github.com/SerenityNotes/serenity-notes-clients/blob/main/app/src/utils/device/index.ts

### Contact

## Note encryption

## Private Info Encryption

- Devices
- Contacts -->

## Processes

### Server Authentication

In order to authorize with the server a client must send an `authorization` header.
This header must must start with a prefix `signed-utc-msg` followed by the device's Ed25519 public key.
Next up there must be an ISO 8601 datetime string and then a signature of the ISO 8601 datetime string.

Structure:

```
signed-utc-msg ${ed25519_public_key} ${ISO_8601_datetime_string} ${signature_of_ISO_8601_datetime_string}
```

The server validates the authenticity of header by verifying the combination of public key, message and signature.
Since the API is secured using HTTPS the `authorization` header should never be exposed.
The server will only accept requests that are within a 10 minute timeframe.
The reason for this is to make sure that in case a CA gets compromised an old `authorization` header can't be used to authorize against the server.

#### Possible Improvements

This approach requires that the clock of the client is roughly in synchronization with the server.
In order to avoid that the authorization process could change that every client does a pre-flight request to retrieve a session ID including an expiration datetime.
The client would then sign the session ID and the server could verify the authenticity. When the session is soon to expire the client will request a new session.

<!--

### Signup Process

### Device Linking

### Adding and verifying Contacts -->
