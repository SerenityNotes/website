export const meta = {
  title: "Technical Documentation",
  publishedAt: "2021-05-14",
  modifiedAt: "2021-05-14",
};

# Technical Documentation

Please note that this documentation is a work-in-progress and will be improved over the coming weeks.

## Desired Behaviour

### End-to-end encryption of sensitive information

This includes the content and title of notes, the contact names and the device names.

### Rely on state-of-the-art encryption

The end-to-end encryption must using the [Olm & Megolm](https://gitlab.matrix.org/matrix-org/olm) cryptographic ratchets and follow the documentation's best practices
e.g. periodically start new sessions to establish [Backward secrecy](https://intensecrypto.org/public/lec_08_hash_functions_part2.html#sec-forward-and-backward-secrecy).

### Devices and contacts must be verified

This means currently data is only encrypted for a user's devices or contacts which have been verified by the user.
This might change with the introduction of cross-signing for contacts of contacts or the some form of organisation concept.

## Entities

### User

A user has one Ed25519 keypair. The private key must be storred in a secure store on the device (e.g Keychain Services or Android keystore system).
In addition a user has a user ID which is generated by the server.

#### Possible Improvements

In the future there ideally would be multiple Ed25519 keypairs per user.
This way one keypair could invalid e.g. when a user looses a device and wants to invalidate one keypair, but not the others.
The downside of this is that it increases complexity for contact and device verification.

### Device

A user can have several devices. Each device has

- one Ed25519 fingerprint key pair and
- one Curve25519 identity key pair

The private keys of both must never leave the device and must be stored in a secure store (e.g Keychain Services or Android keystore system).

In addition each device creates a number of Curve25519 one-time key pairs. These are used to establish Olm session. To avoid running out of possible sessions also a Curve25519 fallback key pair must be available.
For the fallback key also a signature must exist signed with the device's Ed25519 keypair.

Further every device must have a `signingKey` signed by the user Ed25519 keypair to allow verification
that this device belongs to this user. This key is a stringified JSON object with the following structure:

```js
{
  version: 1,
  message: `${public_Ed25519_user_signing_key} ${public_Ed25519_device_signing_key} ${device_id_key}`,
  signature: `${Ed25519_user_signature_of_the_message}`,
}
```

The `public_Ed25519_user_signing_key` is included to later support multiple user signing keys per user.

#### Possible Improvement

One-time key pairs should also have a matching signature for another device to verify if the one-time key was actually created by the expected device.

### Note

#### Creating a Note

When a note is created all devices of a user and one one-time key per devices are fetched from the server.
Each device is verified using the user Ed25519 keypair and the ones which aren't valid are filtered out.

A new Megolm group session is initialized and the content of the note is encrypted with it.
For each verified device a new Olm session is initialized and a message created containing the
keys to decrypt the Megolm session.

The encrypted note as well as all the Olm messages (GroupSessionMessage) are sent to the server via the GraphQL mutation `createRepository`.
The server responds with an ID and an ID per GroupSessionMessage. On the client the following data is persistet:

- id (server)
- groupSession
- groupSessionMessageIds
- creation time of the group session

#### Updating a Note

If the Note create is older than 24h a new group session must be initialized.

More coming soon …

### Contact

A contact is another user that has verified through the contact adding/verification flow. In this process
each user creates a stringified JSON object with the following structure:

```js
{
  version: 1,
  message: `${public_Ed25519_user_signing_key} ${public_Ed25519_user_signing_key_of_the_other_person}`,
  signature: `${Ed25519_user_signature_of_the_message}`,
}
```

It includes a message which contains the public Ed25519 keys of both users. This message must be
signed with the users Ed25519 keypair. With this signature all your devices can verify that
this is the Ed25519 keypair of the other user.

Since this the same Ed25519 keypair used to sign devices everyone also can verify that a certain
device belongs to this user.

In order to encrypt data for another contact that data is encrypted for each device. In order to
do so all devices of all contacts must be fetched from the server and verified.

The `public_Ed25519_user_signing_key` is included to later support multiple user signing keys per user.

#### Adding a contact to a note

Coming soon …

#### Removing a contact from a Note

Coming soon …

### Private info

Every user has one "private info" data structure to make sure sensible information can be
exchanged between the user's devices without the server knowing about the content.

The following data is stored in there:

- devices (public device Curve25519 key, public device Ed25519 key, device name, app name)
- contacts (server user ID, name, public user Ed25519 key)
- contact invitations (server contact invitation ID, user ID, public user Ed25519 key, client secret, server secret)

The private info is encrypted as a Megolm session. For each verified device of user a new Olm session is initialized and a message created containing the
keys to decrypt the Megolm session. In contrast to notes every update must be a new Megolm session.

## Flows

### Server Authentication

In order to authorize with the server a client must send an `authorization` header.
This header must must start with a prefix `signed-utc-msg` followed by the device's Ed25519 public key.
Next up there must be an ISO 8601 datetime string and then a signature of the ISO 8601 datetime string.

Structure:

```
signed-utc-msg ${device_ed25519_public_key} ${ISO_8601_datetime_string} ${signature_of_ISO_8601_datetime_string}
```

The server validates the authenticity of header by verifying the combination of public key, message and signature.
Since the API is secured using HTTPS the `authorization` header should never be exposed.
The server will only accept requests that are within a 10 minute timeframe.
The reason for this is to make sure that in case a CA gets compromised an old `authorization` header can't be used to authorize against the server.

#### Possible Improvements

This approach requires that the clock of the client is roughly in synchronization with the server.
In order to avoid that the authorization process could change that every client does a pre-flight request to retrieve a session ID including an expiration datetime.
The client would then sign the session ID and the server could verify the authenticity. When the session is soon to expire the client will request a new session.

### Signup Process

A new device (Ed25519 fingerprint key pair and one Curve25519 identity key pair) are created.

Coming soon …

### Device Linking

This flow is designed to mitigate man-in-the-middle attacks.

Coming soon …

### Removing a device

Coming soon …

### Adding and verifying Contacts

Coming soon …

### Removing a contact

Coming soon …

## Known meta data to the server

The server's main purpose is to transfer the encrypted data between devices. Nevertheless a lot of meta data can be extracted:

- amount of users
- amount of notes
- amount of deleted notes
- amount of updates per note and when they occured
- contact connections per user
- amount of devices per user

In addition once a billing account is setup and connected to the account all the billing information
can be connected to the user.

### Possible Improvement

In the future only the last or last couple note updates will be stored and older once are removed.
