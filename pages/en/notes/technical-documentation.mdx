export const meta = {
  title: "Technical Documentation",
  publishedAt: "2021-05-14",
  modifiedAt: "2021-05-14",
};

# Technical Documentation

## Entities

### User

A user has one Ed25519 keypair. The private key must be storred in a secure store on the device (e.g Keychain Services or Android keystore system).
In addition a user has a user ID which is generated by the server.

#### Possible Improvements

In the future there ideally would be multiple Ed25519 keypairs per user.
This way one keypair could invalid e.g. when a user looses a device and wants to invalidate one keypair, but not the others.
The downside of this is that it increases complexity for contact and device verification.

### Device

A user can have several devices. Each device has

- one Ed25519 fingerprint key pair and
- one Curve25519 identity key pair

The private keys of both must never leave the device and must be stored in a secure store (e.g Keychain Services or Android keystore system).

In addition each device creates a number of Curve25519 one-time key pairs. These are used to establish Olm session. To avoid running out of possible sessions also a Curve25519 fallback key pair must be available.
For the fallback key also a signature must exist signed with the device's Ed25519 keypair.

Further every device must have a `signingKey` signed by the user Ed25519 keypair to allow verification
that this device belongs to this user. This key is a stringified JSON object with the following structure:

```js
{
  version: 1,
  message: `${public_Ed25519_user_signing_key} ${public_Ed25519_device_signing_key} ${device_id_key}`,
  signature: `${Ed25519_user_signature_of_the_message}`,
}
```

The `public_Ed25519_user_signing_key` is included to later support multiple user signing keys per user.

#### Possible Improvement

One-time key pairs should also have a matching signature for another device to verify if the one-time key was actually created by the expected device.

### Contact

Coming soon …

### Note

#### Creating a Note

When a note is created all devices of a user and one one-time key per devices are fetched from the server.
Each device is verified using the user Ed25519 keypair and the ones which aren't valid are filtered out.

A new Megolm group session is initialized and the content of the note is encrypted with it.
For each verified device a new Olm session is initialized and a message created containing the
keys to decrypt the Megolm session.

The encrypted note as well as all the Olm messages (GroupSessionMessage) are sent to the server via the GraphQL mutation `createRepository`.
The server responds with an ID and an ID per GroupSessionMessage. On the client the following data is persistet:

- id (server)
- groupSession
- groupSessionMessageIds
- creation time of the group session

#### Updating a Note

If the Note create is older than 24h a new group session must be initialized.

More coming soon …

#### Adding a contact to a note

Coming soon …

#### Removing a contact from a Note

Coming soon …

### Private info

Every user has one "private info" data structure to make sure sensible information can be
exchanged between the user's devices without the server knowing about the content.

The following data is stored in there:

- devices (public device Curve25519 key, public device Ed25519 key, device name, app name)
- contacts (server user ID, name, public user Ed25519 key)
- contact invitations (server contact invitation ID, user ID, public user Ed25519 key, client secret, server secret)

The private info is encrypted as a Megolm session. For each verified device of user a new Olm session is initialized and a message created containing the
keys to decrypt the Megolm session. In contrast to notes every update must be a new Megolm session.

## Flows

### Server Authentication

In order to authorize with the server a client must send an `authorization` header.
This header must must start with a prefix `signed-utc-msg` followed by the device's Ed25519 public key.
Next up there must be an ISO 8601 datetime string and then a signature of the ISO 8601 datetime string.

Structure:

```
signed-utc-msg ${device_ed25519_public_key} ${ISO_8601_datetime_string} ${signature_of_ISO_8601_datetime_string}
```

The server validates the authenticity of header by verifying the combination of public key, message and signature.
Since the API is secured using HTTPS the `authorization` header should never be exposed.
The server will only accept requests that are within a 10 minute timeframe.
The reason for this is to make sure that in case a CA gets compromised an old `authorization` header can't be used to authorize against the server.

#### Possible Improvements

This approach requires that the clock of the client is roughly in synchronization with the server.
In order to avoid that the authorization process could change that every client does a pre-flight request to retrieve a session ID including an expiration datetime.
The client would then sign the session ID and the server could verify the authenticity. When the session is soon to expire the client will request a new session.

### Signup Process

A new device (Ed25519 fingerprint key pair and one Curve25519 identity key pair) are created.

Coming soon …

### Device Linking

Coming soon …

### Removing a device

Coming soon …

### Adding and verifying Contacts

Coming soon …

### Removing a contact

Coming soon …
